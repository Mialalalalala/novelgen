<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Novel Store</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      color: #333;
      line-height: 1.6;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    header {
      background: white;
      padding: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .novels-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }
    .novel-card {
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }
    .novel-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .novel-cover {
      width: 100%;
      height: 200px;
      object-fit: cover;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .novel-info {
      padding: 15px;
    }
    .novel-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
      color: #333;
    }
    .novel-author {
      color: #666;
      font-size: 14px;
      margin-bottom: 8px;
    }
    .novel-genre {
      display: inline-block;
      background: #e0e0e0;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      margin-bottom: 10px;
    }
    .novel-price {
      font-size: 20px;
      font-weight: bold;
      color: #667eea;
      margin-top: 10px;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
      overflow-y: auto;
    }
    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 8px;
      max-width: 800px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      margin: 20px;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
    }
    .novel-content {
      line-height: 1.8;
      margin: 20px 0;
    }
    .purchase-form {
      background: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      margin-top: 20px;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .buy-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
    }
    .buy-btn:hover {
      background: #5568d3;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }
    
    /* Interactive Features */
    .interactive-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    @media (max-width: 768px) {
      .interactive-section {
        grid-template-columns: 1fr;
      }
    }
    .feature-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      padding: 20px;
      color: white;
    }
    .feature-card h3 {
      margin: 0 0 15px 0;
      font-size: 18px;
    }
    .feature-input {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      margin-bottom: 10px;
    }
    .feature-btn {
      background: white;
      color: #667eea;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      transition: transform 0.2s;
    }
    .feature-btn:hover {
      transform: scale(1.02);
    }
    .feature-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    /* Image Type Buttons */
    .img-type-btn {
      background: rgba(255,255,255,0.2);
      color: white;
      border: 2px solid rgba(255,255,255,0.3);
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .img-type-btn:hover {
      background: rgba(255,255,255,0.3);
    }
    .img-type-btn.active {
      background: white;
      color: #667eea;
      border-color: white;
      font-weight: bold;
    }
    
    /* Voice Chat */
    .voice-btn {
      background: #fff;
      border: none;
      width: 50px;
      height: 40px;
      border-radius: 20px;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s;
      flex-shrink: 0;
    }
    .voice-btn:hover {
      transform: scale(1.1);
    }
    .voice-btn.recording {
      background: #ff4444;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .voice-status {
      text-align: center;
      font-size: 12px;
      color: rgba(255,255,255,0.8);
      margin-top: 8px;
      min-height: 20px;
    }
    .play-voice-btn {
      background: rgba(255,255,255,0.3);
      border: none;
      padding: 4px 8px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      margin-left: 8px;
      transition: all 0.2s;
    }
    .play-voice-btn:hover {
      background: rgba(255,255,255,0.5);
    }
    .play-voice-btn.playing {
      background: #4CAF50;
    }
    
    /* Character Chat Section */
    .character-chat-section {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      padding: 20px;
      margin: 20px 0;
      color: white;
    }
    .character-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    .character-container {
      position: relative;
      width: 200px;
      height: 280px;
      margin-bottom: 15px;
    }
    
    /* Character wrapper for animations */
    .character-wrapper {
      position: relative;
      width: 200px;
      height: 250px;
      animation: idleBreath 4s ease-in-out infinite;
    }
    .character-wrapper.thinking {
      animation: thinkingMotion 2s ease-in-out infinite;
    }
    .character-wrapper.speaking {
      animation: speakingMotion 0.3s ease-in-out infinite;
    }
    
    /* Idle breathing animation */
    @keyframes idleBreath {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-3px) scale(1.01); }
    }
    
    /* Thinking animation - head tilt */
    @keyframes thinkingMotion {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-2px) rotate(-2deg); }
      75% { transform: translateY(-2px) rotate(2deg); }
    }
    
    /* Speaking animation - more dynamic */
    @keyframes speakingMotion {
      0%, 100% { transform: translateY(0) scale(1); }
      25% { transform: translateY(-2px) scale(1.02) rotate(-1deg); }
      50% { transform: translateY(-4px) scale(1.01); }
      75% { transform: translateY(-2px) scale(1.02) rotate(1deg); }
    }
    
    .character-image {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid white;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    
    /* Mouth animation overlay */
    .character-mouth {
      position: absolute;
      bottom: 55px;
      left: 50%;
      transform: translateX(-50%);
      width: 30px;
      height: 8px;
      background: rgba(0,0,0,0.1);
      border-radius: 50%;
      opacity: 0;
      transition: all 0.1s;
    }
    .character-wrapper.speaking .character-mouth {
      opacity: 1;
      animation: mouthMove 0.2s ease-in-out infinite;
    }
    @keyframes mouthMove {
      0%, 100% { 
        height: 8px; 
        width: 30px;
        border-radius: 50%;
      }
      50% { 
        height: 16px; 
        width: 24px;
        border-radius: 50%;
      }
    }
    
    /* Blinking eyes overlay */
    .character-eyes {
      position: absolute;
      top: 75px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
    }
    .character-eye {
      width: 8px;
      height: 8px;
      background: transparent;
      border-radius: 50%;
      animation: blink 4s infinite;
    }
    .character-eye::after {
      content: '';
      position: absolute;
      width: 8px;
      height: 3px;
      background: rgba(0,0,0,0.15);
      border-radius: 50%;
      opacity: 0;
    }
    @keyframes blink {
      0%, 95%, 100% { transform: scaleY(1); }
      97% { transform: scaleY(0.1); }
    }
    
    /* Sound wave animation when speaking */
    .sound-waves {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 4px;
      align-items: flex-end;
      height: 20px;
      opacity: 0;
    }
    .character-wrapper.speaking .sound-waves {
      opacity: 1;
    }
    .sound-wave {
      width: 4px;
      background: #4CAF50;
      border-radius: 2px;
      animation: soundWave 0.5s ease-in-out infinite;
    }
    .sound-wave:nth-child(1) { animation-delay: 0s; }
    .sound-wave:nth-child(2) { animation-delay: 0.1s; }
    .sound-wave:nth-child(3) { animation-delay: 0.2s; }
    .sound-wave:nth-child(4) { animation-delay: 0.1s; }
    .sound-wave:nth-child(5) { animation-delay: 0s; }
    @keyframes soundWave {
      0%, 100% { height: 8px; }
      50% { height: 20px; }
    }
    
    /* Speaking indicator */
    .character-speaking-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 20px;
      height: 20px;
      background: #4CAF50;
      border-radius: 50%;
      display: none;
      animation: pulse 1s infinite;
      box-shadow: 0 0 10px #4CAF50;
    }
    .character-speaking-indicator.active {
      display: block;
    }
    
    /* Emotion particles */
    .emotion-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
    }
    .particle {
      position: absolute;
      font-size: 16px;
      opacity: 0;
    }
    .character-wrapper.speaking .particle {
      animation: floatUp 2s ease-out infinite;
    }
    .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
    .particle:nth-child(2) { left: 80%; animation-delay: 0.5s; }
    .particle:nth-child(3) { left: 20%; animation-delay: 1s; }
    @keyframes floatUp {
      0% { 
        transform: translateY(200px) scale(0.5); 
        opacity: 0; 
      }
      50% { 
        opacity: 1; 
      }
      100% { 
        transform: translateY(-20px) scale(1); 
        opacity: 0; 
      }
    }
    .character-speech {
      background: white;
      color: #333;
      padding: 15px 20px;
      border-radius: 20px;
      max-width: 90%;
      position: relative;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .character-speech::before {
      content: '';
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 10px solid white;
    }
    .speech-text {
      flex: 1;
      font-size: 16px;
      line-height: 1.5;
    }
    .speech-play-btn {
      background: #667eea;
      color: white;
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      transition: all 0.2s;
    }
    .speech-play-btn:hover {
      transform: scale(1.1);
    }
    .speech-play-btn.playing {
      background: #4CAF50;
    }
    .character-input-area {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .character-voice-btn {
      background: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s;
      flex-shrink: 0;
    }
    .character-voice-btn:hover {
      transform: scale(1.1);
    }
    .character-voice-btn.recording {
      background: #ff4444;
      animation: pulse 1s infinite;
    }
    .character-input {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: 25px;
      font-size: 14px;
    }
    .character-send-btn {
      background: white;
      color: #667eea;
      border: none;
      padding: 12px 20px;
      border-radius: 25px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    .character-send-btn:hover {
      transform: scale(1.05);
    }
    .character-status {
      text-align: center;
      font-size: 12px;
      margin-top: 10px;
      min-height: 20px;
      opacity: 0.9;
    }
    
    /* Chat Interface */
    .chat-container {
      background: #f8f9fa;
      border-radius: 8px;
      height: 300px;
      display: flex;
      flex-direction: column;
    }
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }
    .chat-message {
      margin-bottom: 12px;
      display: flex;
      gap: 10px;
    }
    .chat-message.user {
      flex-direction: row-reverse;
    }
    .chat-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      flex-shrink: 0;
    }
    .chat-message.user .chat-avatar {
      background: #667eea;
    }
    .chat-message.assistant .chat-avatar {
      background: #ff6b9d;
    }
    .chat-bubble {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 18px;
      font-size: 14px;
      line-height: 1.4;
    }
    .chat-message.user .chat-bubble {
      background: #667eea;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .chat-message.assistant .chat-bubble {
      background: white;
      color: #333;
      border-bottom-left-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .chat-input-area {
      display: flex;
      gap: 10px;
      padding: 10px;
      border-top: 1px solid #eee;
      background: white;
      border-radius: 0 0 8px 8px;
    }
    .chat-input {
      flex: 1;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-radius: 20px;
      font-size: 14px;
      outline: none;
    }
    .chat-input:focus {
      border-color: #667eea;
    }
    .chat-send {
      background: #667eea;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
    }
    .chat-send:disabled {
      opacity: 0.5;
    }
    
    /* Generated Image */
    .generated-image-container {
      margin-top: 15px;
      text-align: center;
    }
    .generated-image {
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>ğŸ“š AI Novel Store</h1>
    </div>
  </header>

  <div class="container">
    <div id="novels-container" class="loading">Loading...</div>
  </div>

  <!-- Novel Detail Modal -->
  <div id="novel-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="modal-title"></h2>
        <button class="close-btn" onclick="closeModal()">&times;</button>
      </div>
      <div id="modal-body"></div>
    </div>
  </div>

  <script type="module">
    // Import Sanity client from CDN
    import { createClient } from 'https://esm.sh/@sanity/client@6'
    
    // Initialize Sanity client
    const client = createClient({
      projectId: '9cp0f5xw', // Replace with your Sanity project ID
      dataset: 'production', // Replace with your dataset name
      useCdn: true,
      apiVersion: '2024-01-01',
      // If you encounter CORS issues, you can add a token (need to create a read token in Sanity console first)
      // token: 'your-read-token-here'
    })
    
    // Add debug info
    console.log('Sanity client initialized:', {
      projectId: '9cp0f5xw',
      dataset: 'production',
      currentUrl: window.location.href
    })
    
    // API URL - Update to actual API address when deploying
    // Local development: 'http://localhost:3000/api/generate-novel'
    // Production: 'https://your-project.vercel.app/api/generate-novel'
    const API_BASE_URL = window.location.origin.includes('localhost') 
      ? 'http://localhost:3000' 
      : window.location.origin

    // Fetch and display novels
    async function loadNovels() {
      try {
        console.log('Starting to load novels...')
        const novels = await client.fetch(`
          *[_type == "novel"] | order(_createdAt desc) {
            _id,
            title,
            slug,
            coverImage,
            description,
            price,
            currency,
            genre,
            author,
            wordCount,
            "coverUrl": coverImage.asset->url
          }
        `)
        console.log('Novels fetched:', novels)

        const container = document.getElementById('novels-container')
        
        if (novels.length === 0) {
          container.innerHTML = '<div class="empty-state"><h2>No Novels Available</h2><p>Please create and publish novels in Sanity Studio first</p></div>'
          return
        }

        container.className = 'novels-grid'
        container.innerHTML = novels.map(novel => `
          <div class="novel-card" onclick="showNovelDetail('${novel._id}')">
            <img src="${novel.coverUrl || 'https://via.placeholder.com/280x200?text=No+Cover'}" 
                 alt="${novel.title}" 
                 class="novel-cover"
                 onerror="this.style.display='none'">
            <div class="novel-info">
              <div class="novel-title">${novel.title || 'Untitled'}</div>
              <div class="novel-author">${novel.author || 'Unknown Author'}</div>
              <span class="novel-genre">${novel.genre || 'General'}</span>
              <div class="novel-price">
                ${getCurrencySymbol(novel.currency)}${novel.price || 0}
              </div>
            </div>
          </div>
        `).join('')
      } catch (error) {
        console.error('Error loading novels:', error)
        const container = document.getElementById('novels-container')
        container.className = 'empty-state'
        
        // Check if it's a CORS error
        const isCorsError = error.message?.includes('CORS') || 
                          error.message?.includes('Failed to fetch') ||
                          error.message?.includes('NetworkError')
        
        container.innerHTML = `
          <div class="empty-state">
            <h2>Failed to Load</h2>
            <p>Error: ${error.message || 'Unknown error'}</p>
            ${isCorsError ? `
              <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border: 1px solid #ffc107;">
                <h3 style="margin: 0 0 10px 0; color: #856404;">âš ï¸ CORS Configuration Required</h3>
                <p style="margin: 0; color: #856404;">
                  Your frontend domain needs to be added to Sanity's CORS settings.<br><br>
                  <strong>Steps to fix:</strong><br>
                  1. Go to <a href="https://www.sanity.io/manage" target="_blank">https://www.sanity.io/manage</a><br>
                  2. Select project: <strong>9cp0f5xw</strong><br>
                  3. Go to <strong>API</strong> > <strong>CORS origins</strong><br>
                  4. Add: <strong>${window.location.origin}</strong><br>
                  5. Check <strong>Allow credentials</strong><br>
                  6. Click <strong>Save</strong><br>
                  7. Refresh this page
                </p>
              </div>
            ` : ''}
            <p style="margin-top: 10px; font-size: 12px; color: #666;">
              Please check:<br>
              1. Sanity Project ID is correct<br>
              2. Dataset name is correct<br>
              3. CORS settings are correct<br>
              4. Browser console for more error details
            </p>
            <p style="margin-top: 10px; font-size: 12px;">
              <strong>Debug Info:</strong><br>
              Project ID: 9cp0f5xw<br>
              Dataset: production<br>
              Current URL: ${window.location.href}<br>
              Origin: ${window.location.origin}
            </p>
          </div>
        `
      }
    }

    // Show novel detail
    async function showNovelDetail(novelId) {
      try {
        const novel = await client.fetch(`
          *[_type == "novel" && _id == $id][0] {
            _id,
            title,
            slug,
            coverImage,
            description,
            content,
            price,
            currency,
            genre,
            author,
            scenes,
            "coverUrl": coverImage.asset->url
          }
        `, { id: novelId })

        if (!novel) {
          alert('Novel not found')
          return
        }

        document.getElementById('modal-title').textContent = novel.title || 'Untitled'
        
        const modalBody = document.getElementById('modal-body')
        modalBody.innerHTML = `
          <div style="text-align: center; margin-bottom: 20px;">
            ${novel.coverUrl ? `<img src="${novel.coverUrl}" alt="${novel.title}" style="max-width: 200px; border-radius: 8px;">` : ''}
          </div>
          <div style="margin-bottom: 15px;">
            <strong>Author:</strong> ${novel.author || 'Unknown'}<br>
            <strong>Genre:</strong> ${novel.genre || 'General'}
          </div>
          ${novel.description ? `<p style="margin-bottom: 20px; color: #666;">${novel.description}</p>` : ''}
          
          <!-- Interactive Features -->
          <div class="interactive-section">
            <!-- Image Generation -->
            <div class="feature-card">
              <h3>ğŸ¨ AI ç»˜å›¾</h3>
              <p style="font-size: 12px; margin-bottom: 10px; opacity: 0.9;">æ ¹æ®å°è¯´å†…å®¹ç”Ÿæˆä¸“å±å›¾ç‰‡</p>
              
              <!-- Image Type Selection -->
              <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
                <button class="img-type-btn active" data-novel="${novel._id}" data-type="heroine" onclick="selectImageType('${novel._id}', 'heroine', this)">ğŸ‘© å¥³ä¸»</button>
                <button class="img-type-btn" data-novel="${novel._id}" data-type="hero" onclick="selectImageType('${novel._id}', 'hero', this)">ğŸ‘¨ ç”·ä¸»</button>
                <button class="img-type-btn" data-novel="${novel._id}" data-type="scene" onclick="selectImageType('${novel._id}', 'scene', this)">ğŸ¬ ååœºé¢</button>
                <button class="img-type-btn" data-novel="${novel._id}" data-type="couple" onclick="selectImageType('${novel._id}', 'couple', this)">ğŸ’‘ CPåŒæ¡†</button>
                <button class="img-type-btn" data-novel="${novel._id}" data-type="villain" onclick="selectImageType('${novel._id}', 'villain', this)">ğŸ˜ˆ åæ´¾</button>
                <button class="img-type-btn" data-novel="${novel._id}" data-type="custom" onclick="selectImageType('${novel._id}', 'custom', this)">âœï¸ è‡ªå®šä¹‰</button>
              </div>
              
              <input type="hidden" id="img-type-${novel._id}" value="heroine" />
              
              <input 
                type="text" 
                id="scene-prompt-${novel._id}"
                class="feature-input" 
                placeholder="è¡¥å……æè¿°ï¼ˆå¯é€‰ï¼‰ï¼Œå¦‚ï¼šç©¿çº¢è‰²æ™šç¤¼æœã€éœ¸æ°”ä¾§æ¼..."
              />
              <button 
                class="feature-btn" 
                onclick="generateSceneImage('${novel._id}', '${novel.title}', '${novel.genre}')"
                id="gen-img-btn-${novel._id}"
              >
                âœ¨ ç”Ÿæˆå›¾ç‰‡
              </button>
              <div id="generated-image-${novel._id}" class="generated-image-container"></div>
            </div>
            
          </div>
          
          <!-- Character Chat Section -->
          <div class="character-chat-section" id="character-chat-${novel._id}">
            <h3 style="text-align: center; margin-bottom: 15px;">ğŸ™ï¸ å’Œå¥³ä¸»å¯¹è¯</h3>
            
            <!-- Character Display -->
            <div class="character-stage">
              <div class="character-container" id="character-container-${novel._id}">
                <div class="character-wrapper" id="character-wrapper-${novel._id}">
                  <img 
                    src="https://api.dicebear.com/7.x/lorelei/svg?seed=${novel._id}&backgroundColor=ffdfbf" 
                    alt="å¥³ä¸»" 
                    class="character-image"
                    id="character-image-${novel._id}"
                  />
                  <!-- Eye blink overlay -->
                  <div class="character-eyes">
                    <div class="character-eye"></div>
                    <div class="character-eye"></div>
                  </div>
                  <!-- Mouth animation overlay -->
                  <div class="character-mouth"></div>
                  <!-- Emotion particles -->
                  <div class="emotion-particles">
                    <span class="particle">âœ¨</span>
                    <span class="particle">ğŸ’•</span>
                    <span class="particle">ğŸŒ¸</span>
                  </div>
                  <!-- Sound waves -->
                  <div class="sound-waves">
                    <div class="sound-wave"></div>
                    <div class="sound-wave"></div>
                    <div class="sound-wave"></div>
                    <div class="sound-wave"></div>
                    <div class="sound-wave"></div>
                  </div>
                </div>
                <div class="character-speaking-indicator" id="speaking-indicator-${novel._id}"></div>
              </div>
              
              <!-- Speech Bubble -->
              <div class="character-speech" id="character-speech-${novel._id}">
                <div class="speech-text" id="speech-text-${novel._id}">å—¨ï½ç‚¹å‡»ä¸‹é¢çš„éº¦å…‹é£å’Œæˆ‘èŠå¤©å§ï½ ğŸ˜Š</div>
                <button class="speech-play-btn" id="speech-play-${novel._id}" onclick="playCurrentSpeech('${novel._id}')">ğŸ”Š</button>
              </div>
            </div>
            
            <!-- Chat Input -->
            <div class="character-input-area">
              <button 
                class="character-voice-btn"
                onclick="startCharacterChat('${novel._id}', '${novel.title}', '${novel.genre}')"
                id="char-voice-btn-${novel._id}"
              >
                ğŸ¤
              </button>
              <input 
                type="text" 
                class="character-input" 
                id="char-input-${novel._id}"
                placeholder="è¾“å…¥æ¶ˆæ¯æˆ–ç‚¹å‡»éº¦å…‹é£è¯´è¯..."
                onkeypress="if(event.key==='Enter')sendCharacterChat('${novel._id}', '${novel.title}', '${novel.genre}')"
              />
              <button 
                class="character-send-btn" 
                onclick="sendCharacterChat('${novel._id}', '${novel.title}', '${novel.genre}')"
                id="char-send-${novel._id}"
              >
                å‘é€
              </button>
            </div>
            <div id="char-status-${novel._id}" class="character-status"></div>
          </div>
          
          <!-- Novel Continuation -->
          <div class="feature-card" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); margin: 20px 0;">
            <h3>âœï¸ AI ç»­å†™å°è¯´</h3>
            <p style="font-size: 12px; margin-bottom: 10px; opacity: 0.9;">å‘Šè¯‰ AI ä½ æƒ³çœ‹ä»€ä¹ˆå‰§æƒ…å‘å±•</p>
            <textarea 
              id="continue-prompt-${novel._id}"
              class="feature-input" 
              style="min-height: 80px; resize: vertical;"
              placeholder="è¾“å…¥ä½ æƒ³è¦çš„å‰§æƒ…ï¼Œä¾‹å¦‚ï¼š&#10;â€¢ å¥³ä¸»å‘ç°æ¸£ç”·å‡ºè½¨è¯æ®ï¼Œå½“åœºæ‰“è„¸&#10;â€¢ å¥³ä¸»åœ¨å…¬å¸ä¼šè®®ä¸Šé€†è¢­ï¼Œè®©æ‰€æœ‰äººåˆ®ç›®ç›¸çœ‹&#10;â€¢ ç”·äºŒæ·±æƒ…å‘Šç™½ï¼Œå¥³ä¸»çŠ¹è±«..."
            ></textarea>
            <button 
              class="feature-btn" 
              onclick="continueNovel('${novel._id}', '${novel.title}', '${novel.genre}')"
              id="continue-btn-${novel._id}"
            >
              ğŸ“ ç”Ÿæˆå‰§æƒ…
            </button>
            <div id="continuation-result-${novel._id}" class="continuation-container" style="margin-top: 15px; display: none;">
              <h4 style="margin: 0 0 10px 0; color: white;">ğŸ“– æ–°å‰§æƒ…ï¼š</h4>
              <div id="continuation-text-${novel._id}" style="background: rgba(255,255,255,0.95); color: #333; padding: 15px; border-radius: 8px; line-height: 1.8; max-height: 400px; overflow-y: auto;"></div>
            </div>
          </div>

          ${novel.scenes && novel.scenes.length > 0 ? `
            <div style="margin: 20px 0;">
              <h3 style="margin-bottom: 15px;">ğŸ¨ AI Generated Scenes</h3>
              <div style="display: grid; gap: 15px; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                ${novel.scenes.filter(s => s.status === 'completed' && s.imageUrl).map(scene => `
                  <div style="background: #f5f5f5; border-radius: 8px; padding: 15px;">
                    <h4 style="margin: 0 0 10px 0;">${scene.title || 'Scene'}</h4>
                    <img 
                      src="${scene.imageUrl}" 
                      alt="${scene.title || 'Scene'}"
                      style="width: 100%; border-radius: 8px; max-height: 300px; object-fit: cover;"
                      onerror="this.src='https://via.placeholder.com/400x300?text=Image+Not+Available'"
                    />
                    ${scene.description ? `<p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">${scene.description.substring(0, 100)}...</p>` : ''}
                  </div>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <div class="novel-content" id="novel-content"></div>
          <div class="purchase-form">
            <h3 style="margin-bottom: 15px;">Purchase Novel</h3>
            <form id="purchase-form" onsubmit="handlePurchase(event, '${novel._id}', ${novel.price}, '${novel.currency}')">
              <div class="form-group">
                <label>Name *</label>
                <input type="text" name="name" required>
              </div>
              <div class="form-group">
                <label>Email *</label>
                <input type="email" name="email" required>
              </div>
              <div class="form-group">
                <label>Payment Method</label>
                <select name="paymentMethod" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                  <option value="credit_card">Credit Card</option>
                  <option value="paypal">PayPal</option>
                  <option value="bank_transfer">Bank Transfer</option>
                </select>
              </div>
              <div style="text-align: center; margin-top: 15px;">
                <strong style="font-size: 24px; color: #667eea;">
                  ${getCurrencySymbol(novel.currency)}${novel.price || 0}
                </strong>
              </div>
              <button type="submit" class="buy-btn">Buy Now</button>
            </form>
          </div>
        `

        // Render novel content
        if (novel.content && novel.content.length > 0) {
          renderContent(novel.content, document.getElementById('novel-content'))
          // Store content as plain text for chat context
          novelContents[novel._id] = extractTextFromBlocks(novel.content)
        } else {
          document.getElementById('novel-content').innerHTML = '<p style="color: #999;">No content available</p>'
          novelContents[novel._id] = ''
        }

        document.getElementById('novel-modal').classList.add('active')
      } catch (error) {
        console.error('Error loading novel:', error)
        alert('Failed to load novel details')
      }
    }

    // Extract plain text from portable text blocks
    function extractTextFromBlocks(blocks) {
      if (!blocks || blocks.length === 0) return ''
      
      return blocks.map(block => {
        if (block._type === 'block' && block.children) {
          return block.children
            .filter(child => child._type === 'span')
            .map(child => child.text)
            .join('')
        }
        return ''
      }).join('\n')
    }

    // Render Sanity portable text content
    function renderContent(blocks, container) {
      if (!blocks || blocks.length === 0) return
      
      blocks.forEach(block => {
        if (block._type === 'block') {
          const tag = block.style === 'h1' ? 'h2' : block.style === 'h2' ? 'h3' : 'p'
          const element = document.createElement(tag)
          
          if (block.children) {
            block.children.forEach(child => {
              if (child._type === 'span') {
                const text = document.createTextNode(child.text)
                element.appendChild(text)
              }
            })
          }
          
          container.appendChild(element)
        }
      })
    }

    // Handle purchase
    async function handlePurchase(event, novelId, price, currency) {
      event.preventDefault()
      const form = event.target
      const formData = new FormData(form)
      
      const orderData = {
        _type: 'order',
        novel: {
          _type: 'reference',
          _ref: novelId
        },
        customerName: formData.get('name'),
        customerEmail: formData.get('email'),
        amount: price,
        currency: currency,
        paymentMethod: formData.get('paymentMethod'),
        status: 'pending',
        purchasedAt: new Date().toISOString()
      }

      try {
        // In a real app, you would send this to a backend API
        // For this minimal example, we'll just show an alert
        alert(`Order submitted!\n\nName: ${orderData.customerName}\nEmail: ${orderData.customerEmail}\nAmount: ${getCurrencySymbol(currency)}${price}\n\nNote: This is a minimal example. In production, you need to integrate a payment gateway.`)
        
        // Optionally, you can create the order in Sanity
        // await client.create(orderData)
        
        closeModal()
      } catch (error) {
        console.error('Error creating order:', error)
        alert('Failed to submit order. Please try again.')
      }
    }

    // Store chat history per novel
    const chatHistories = {}
    
    // Store novel content for chat context
    const novelContents = {}
    
    // Store character images (generated heroine images)
    const characterImages = {}
    
    // Store current speech text for replay
    const currentSpeechTexts = {}
    
    // Image type selection
    function selectImageType(novelId, type, btn) {
      // Update hidden input
      document.getElementById(`img-type-${novelId}`).value = type
      
      // Update button styles
      document.querySelectorAll(`[data-novel="${novelId}"].img-type-btn`).forEach(b => {
        b.classList.remove('active')
      })
      btn.classList.add('active')
      
      // Update placeholder based on type
      const promptInput = document.getElementById(`scene-prompt-${novelId}`)
      const placeholders = {
        'heroine': 'è¡¥å……æè¿°ï¼ˆå¯é€‰ï¼‰ï¼Œå¦‚ï¼šç©¿çº¢è£™ã€éœ¸æ°”ä¾§æ¼ã€å†·è‰³...',
        'hero': 'è¡¥å……æè¿°ï¼ˆå¯é€‰ï¼‰ï¼Œå¦‚ï¼šæ·±æƒ…å‡è§†ã€è¥¿è£…é©å±¥ã€è…¹é»‘...',
        'scene': 'æè¿°åœºæ™¯ï¼Œå¦‚ï¼šå¥³ä¸»å½“ä¼—æ‰“è„¸ç™½è²èŠ±ã€æ·±å¤œå‘Šç™½...',
        'couple': 'è¡¥å……æè¿°ï¼ˆå¯é€‰ï¼‰ï¼Œå¦‚ï¼šé›¨ä¸­ç›¸æ‹¥ã€å©šç¤¼ç°åœº...',
        'villain': 'è¡¥å……æè¿°ï¼ˆå¯é€‰ï¼‰ï¼Œå¦‚ï¼šé˜´é™©ç‹¡è¯ˆã€å‡è£…æ— è¾œ...',
        'custom': 'è¾“å…¥ä½ æƒ³è¦çš„ä»»ä½•ç”»é¢æè¿°...'
      }
      promptInput.placeholder = placeholders[type] || 'è¾“å…¥æè¿°...'
    }
    
    // Make selectImageType globally available
    window.selectImageType = selectImageType
    
    // Generate Image
    async function generateSceneImage(novelId, novelTitle, genre) {
      const promptInput = document.getElementById(`scene-prompt-${novelId}`)
      const imgTypeInput = document.getElementById(`img-type-${novelId}`)
      const btn = document.getElementById(`gen-img-btn-${novelId}`)
      const container = document.getElementById(`generated-image-${novelId}`)
      
      const userPrompt = promptInput.value.trim()
      const imageType = imgTypeInput ? imgTypeInput.value : 'heroine'
      
      // Custom type requires user input
      if (imageType === 'custom' && !userPrompt) {
        alert('è‡ªå®šä¹‰ç±»å‹è¯·è¾“å…¥æè¿°')
        return
      }
      
      btn.disabled = true
      btn.textContent = 'â³ ç”Ÿæˆä¸­...'
      container.innerHTML = '<p style="color: white; font-size: 14px;">æ­£åœ¨ç”Ÿæˆå›¾ç‰‡ï¼Œè¯·ç¨å€™...</p>'
      
      try {
        // Get novel content for context
        const novelContent = novelContents[novelId] || ''
        
        // Build prompt based on image type
        const typePrompts = {
          'heroine': `å°è¯´ã€Š${novelTitle}ã€‹çš„å¥³ä¸»è§’äººç‰©ç«‹ç»˜ã€‚\nå¥³ä¸»ç‰¹ç‚¹ï¼šèªæ˜ç‹¬ç«‹ã€ç¾ä¸½è‡ªä¿¡ã€æ°”åœºå¼ºå¤§çš„å¤§å¥³ä¸»ã€‚`,
          'hero': `å°è¯´ã€Š${novelTitle}ã€‹çš„ç”·ä¸»è§’äººç‰©ç«‹ç»˜ã€‚\nç”·ä¸»ç‰¹ç‚¹ï¼šå¸…æ°”å¤šé‡‘ã€æ·±æƒ…ä¸“ä¸€ã€è¢«å¥³ä¸»å¸å¼•çš„ä¼˜è´¨ç”·æ€§ã€‚`,
          'scene': `å°è¯´ã€Š${novelTitle}ã€‹çš„ç²¾å½©ååœºé¢ã€‚`,
          'couple': `å°è¯´ã€Š${novelTitle}ã€‹çš„ç”·å¥³ä¸»åŒæ¡†ç”»é¢ã€‚\nCPæ„Ÿï¼šç”œèœœã€æ·±æƒ…ã€åŠ¿å‡åŠ›æ•Œçš„çˆ±æƒ…ã€‚`,
          'villain': `å°è¯´ã€Š${novelTitle}ã€‹çš„åæ´¾è§’è‰²ã€‚\nç‰¹ç‚¹ï¼šè¡¨é¢å–„è‰¯å®åˆ™é˜´é™©ã€ç»¿èŒ¶/ç™½è²èŠ±ã€æœ€åè¢«æ‰“è„¸çš„è§’è‰²ã€‚`,
          'custom': `å°è¯´ã€Š${novelTitle}ã€‹ç›¸å…³å›¾ç‰‡ã€‚`
        }
        
        let fullPrompt = typePrompts[imageType] || typePrompts['custom']
        fullPrompt += '\n\n'
        
        if (novelContent) {
          fullPrompt += `å°è¯´èƒŒæ™¯ï¼š${novelContent.substring(0, 400)}\n\n`
        }
        
        if (userPrompt) {
          fullPrompt += `é¢å¤–è¦æ±‚ï¼š${userPrompt}\n\n`
        }
        
        fullPrompt += `é£æ ¼è¦æ±‚ï¼š${genre || 'å¤§å¥³ä¸»'}é£æ ¼ï¼Œé«˜è´¨é‡æ’ç”»ï¼Œç²¾ç¾äººç‰©ï¼Œç”µå½±æ„Ÿå…‰å½±ï¼Œ${imageType === 'scene' ? 'åœºæ™¯å®å¤§ï¼Œæ°›å›´æ„Ÿå¼º' : 'äººç‰©ç¾å‹ï¼Œäº”å®˜ç²¾è‡´'}ï¼Œä¸­å›½é£/ç°ä»£éƒ½å¸‚é£æ ¼ã€‚`
        
        const response = await fetch(`${API_BASE_URL}/api/generate-image`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            prompt: fullPrompt,
            sceneTitle: userPrompt.substring(0, 30) || imageType,
            novelTitle,
            genre
          }),
        })
        
        if (!response.ok) {
          const error = await response.json()
          throw new Error(error.error || 'Failed to generate image')
        }
        
        const data = await response.json()
        
        let imageUrl = null
        if (data.imageUrl) {
          imageUrl = data.imageUrl
          container.innerHTML = `
            <img src="${data.imageUrl}" alt="Generated scene" class="generated-image" />
            <p style="color: white; font-size: 12px; margin-top: 10px;">âœ¨ ç”ŸæˆæˆåŠŸï¼</p>
          `
        } else if (data.imageData) {
          imageUrl = `data:${data.mimeType};base64,${data.imageData}`
          container.innerHTML = `
            <img src="${imageUrl}" alt="Generated scene" class="generated-image" />
            <p style="color: white; font-size: 12px; margin-top: 10px;">âœ¨ ç”ŸæˆæˆåŠŸï¼</p>
          `
        } else {
          throw new Error('No image in response')
        }
        
        // If this is a heroine image, update the character chat display
        if (imageType === 'heroine' && imageUrl) {
          characterImages[novelId] = imageUrl
          const charImg = document.getElementById(`character-image-${novelId}`)
          if (charImg) {
            charImg.src = imageUrl
            charImg.style.borderRadius = '16px'
          }
        }
        
        promptInput.value = ''
      } catch (error) {
        console.error('Image generation error:', error)
        container.innerHTML = `<p style="color: #ffcccc;">âŒ ç”Ÿæˆå¤±è´¥: ${error.message}</p>`
      } finally {
        btn.disabled = false
        btn.textContent = 'âœ¨ ç”Ÿæˆå›¾ç‰‡'
      }
    }
    
    // Chat with Protagonist
    async function sendChat(novelId, novelTitle, genre) {
      const input = document.getElementById(`chat-input-${novelId}`)
      const btn = document.getElementById(`chat-send-${novelId}`)
      const messagesContainer = document.getElementById(`chat-messages-${novelId}`)
      
      const message = input.value.trim()
      if (!message) return
      
      // Initialize chat history for this novel
      if (!chatHistories[novelId]) {
        chatHistories[novelId] = []
      }
      
      // Add user message to UI
      messagesContainer.innerHTML += `
        <div class="chat-message user">
          <div class="chat-avatar">ğŸ™‹</div>
          <div class="chat-bubble">${message}</div>
        </div>
      `
      
      // Save to history
      chatHistories[novelId].push({ role: 'user', content: message })
      
      input.value = ''
      btn.disabled = true
      messagesContainer.scrollTop = messagesContainer.scrollHeight
      
      // Add typing indicator
      const typingId = `typing-${Date.now()}`
      messagesContainer.innerHTML += `
        <div class="chat-message assistant" id="${typingId}">
          <div class="chat-avatar">ğŸ‘©</div>
          <div class="chat-bubble">æ­£åœ¨è¾“å…¥...</div>
        </div>
      `
      messagesContainer.scrollTop = messagesContainer.scrollHeight
      
      try {
        const response = await fetch(`${API_BASE_URL}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            message,
            novelTitle,
            genre,
            novelContent: novelContents[novelId] || '',
            chatHistory: chatHistories[novelId]
          }),
        })
        
        // Remove typing indicator
        document.getElementById(typingId)?.remove()
        
        if (!response.ok) {
          const error = await response.json()
          throw new Error(error.error || 'Chat failed')
        }
        
        const data = await response.json()
        
        // Add assistant reply to UI
        messagesContainer.innerHTML += `
          <div class="chat-message assistant">
            <div class="chat-avatar">ğŸ‘©</div>
            <div class="chat-bubble">${data.reply}</div>
          </div>
        `
        
        // Save to history
        chatHistories[novelId].push({ role: 'assistant', content: data.reply })
        
      } catch (error) {
        console.error('Chat error:', error)
        document.getElementById(typingId)?.remove()
        messagesContainer.innerHTML += `
          <div class="chat-message assistant">
            <div class="chat-avatar">ğŸ‘©</div>
            <div class="chat-bubble">æŠ±æ­‰ï¼Œæˆ‘æš‚æ—¶æ— æ³•å›å¤...è¯·ç¨åå†è¯• ğŸ’”</div>
          </div>
        `
      } finally {
        btn.disabled = false
        messagesContainer.scrollTop = messagesContainer.scrollHeight
      }
    }
    
    // Voice Chat Functions
    let currentRecognition = null
    let currentAudio = null
    
    // Start voice input
    function startVoiceInput(novelId, novelTitle, genre) {
      const btn = document.getElementById(`voice-btn-${novelId}`)
      const status = document.getElementById(`voice-status-${novelId}`)
      
      // Check for browser support
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition
      if (!SpeechRecognition) {
        status.textContent = 'âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ï¼Œè¯·ä½¿ç”¨ Chrome'
        return
      }
      
      // If already recording, stop
      if (currentRecognition) {
        currentRecognition.stop()
        return
      }
      
      const recognition = new SpeechRecognition()
      recognition.lang = 'zh-CN'
      recognition.continuous = false
      recognition.interimResults = true
      
      recognition.onstart = () => {
        btn.classList.add('recording')
        btn.textContent = 'â¹ï¸'
        status.textContent = 'ğŸ¤ æ­£åœ¨å¬...'
      }
      
      recognition.onresult = (event) => {
        const transcript = Array.from(event.results)
          .map(result => result[0].transcript)
          .join('')
        
        document.getElementById(`chat-input-${novelId}`).value = transcript
        status.textContent = `ğŸ“ ${transcript}`
      }
      
      recognition.onend = () => {
        btn.classList.remove('recording')
        btn.textContent = 'ğŸ¤'
        currentRecognition = null
        
        const input = document.getElementById(`chat-input-${novelId}`)
        if (input.value.trim()) {
          status.textContent = 'âœ… è¯†åˆ«å®Œæˆï¼Œå‘é€ä¸­...'
          sendVoiceChat(novelId, novelTitle, genre)
        } else {
          status.textContent = ''
        }
      }
      
      recognition.onerror = (event) => {
        btn.classList.remove('recording')
        btn.textContent = 'ğŸ¤'
        status.textContent = `âŒ è¯†åˆ«å¤±è´¥: ${event.error}`
        currentRecognition = null
      }
      
      currentRecognition = recognition
      recognition.start()
    }
    
    // Send voice chat (with TTS response)
    async function sendVoiceChat(novelId, novelTitle, genre) {
      const input = document.getElementById(`chat-input-${novelId}`)
      const btn = document.getElementById(`chat-send-${novelId}`)
      const voiceBtn = document.getElementById(`voice-btn-${novelId}`)
      const messagesContainer = document.getElementById(`chat-messages-${novelId}`)
      const status = document.getElementById(`voice-status-${novelId}`)
      
      const message = input.value.trim()
      if (!message) return
      
      if (!chatHistories[novelId]) {
        chatHistories[novelId] = []
      }
      
      // Add user message
      messagesContainer.innerHTML += `
        <div class="chat-message user">
          <div class="chat-avatar">ğŸ™‹</div>
          <div class="chat-bubble">${message}</div>
        </div>
      `
      
      chatHistories[novelId].push({ role: 'user', content: message })
      input.value = ''
      btn.disabled = true
      voiceBtn.disabled = true
      messagesContainer.scrollTop = messagesContainer.scrollHeight
      
      const typingId = `typing-${Date.now()}`
      messagesContainer.innerHTML += `
        <div class="chat-message assistant" id="${typingId}">
          <div class="chat-avatar">ğŸ‘©</div>
          <div class="chat-bubble">æ­£åœ¨æ€è€ƒ...</div>
        </div>
      `
      messagesContainer.scrollTop = messagesContainer.scrollHeight
      
      try {
        // Get chat response
        const chatResponse = await fetch(`${API_BASE_URL}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            message,
            novelTitle,
            genre,
            novelContent: novelContents[novelId] || '',
            chatHistory: chatHistories[novelId]
          }),
        })
        
        document.getElementById(typingId)?.remove()
        
        if (!chatResponse.ok) {
          throw new Error('Chat failed')
        }
        
        const chatData = await chatResponse.json()
        const reply = chatData.reply
        
        // Add reply with play button
        const replyId = `reply-${Date.now()}`
        messagesContainer.innerHTML += `
          <div class="chat-message assistant">
            <div class="chat-avatar">ğŸ‘©</div>
            <div class="chat-bubble">${reply}</div>
            <button class="play-voice-btn" id="play-${replyId}" onclick="playVoice('${replyId}', \`${reply.replace(/`/g, "'").replace(/\\/g, "\\\\")}\`)">ğŸ”Š</button>
          </div>
        `
        
        chatHistories[novelId].push({ role: 'assistant', content: reply })
        messagesContainer.scrollTop = messagesContainer.scrollHeight
        
        // Auto-play the response
        status.textContent = 'ğŸ”Š æ­£åœ¨ç”Ÿæˆè¯­éŸ³...'
        await playVoice(replyId, reply)
        status.textContent = ''
        
      } catch (error) {
        console.error('Voice chat error:', error)
        document.getElementById(typingId)?.remove()
        messagesContainer.innerHTML += `
          <div class="chat-message assistant">
            <div class="chat-avatar">ğŸ‘©</div>
            <div class="chat-bubble">æŠ±æ­‰ï¼Œæˆ‘æš‚æ—¶æ— æ³•å›å¤... ğŸ’”</div>
          </div>
        `
        status.textContent = ''
      } finally {
        btn.disabled = false
        voiceBtn.disabled = false
        messagesContainer.scrollTop = messagesContainer.scrollHeight
      }
    }
    
    // Play voice (TTS)
    async function playVoice(replyId, text) {
      const playBtn = document.getElementById(`play-${replyId}`)
      
      // Stop any currently playing audio
      if (currentAudio) {
        currentAudio.pause()
        currentAudio = null
        document.querySelectorAll('.play-voice-btn').forEach(b => {
          b.classList.remove('playing')
          b.textContent = 'ğŸ”Š'
        })
      }
      
      if (playBtn) {
        playBtn.classList.add('playing')
        playBtn.textContent = 'â³'
      }
      
      try {
        const response = await fetch(`${API_BASE_URL}/api/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, voice: 'nova' }),
        })
        
        if (!response.ok) {
          throw new Error('TTS failed')
        }
        
        const data = await response.json()
        
        if (data.audio) {
          const audio = new Audio(`data:${data.mimeType};base64,${data.audio}`)
          currentAudio = audio
          
          if (playBtn) {
            playBtn.textContent = 'â¸ï¸'
          }
          
          audio.onended = () => {
            if (playBtn) {
              playBtn.classList.remove('playing')
              playBtn.textContent = 'ğŸ”Š'
            }
            currentAudio = null
          }
          
          await audio.play()
        }
      } catch (error) {
        console.error('TTS error:', error)
        if (playBtn) {
          playBtn.classList.remove('playing')
          playBtn.textContent = 'ğŸ”Š'
        }
      }
    }
    
    // Play welcome voice
    async function playWelcomeVoice(novelId) {
      const welcomeText = 'å—¨ï½æˆ‘æ˜¯è¿™ä¸ªæ•…äº‹çš„å¥³ä¸»è§’ï¼ç‚¹å‡»éº¦å…‹é£å’Œæˆ‘è¯´è¯å§ï½'
      await playVoice(`welcome-${novelId}`, welcomeText)
    }
    
    // Make voice functions globally available
    window.startVoiceInput = startVoiceInput
    window.sendVoiceChat = sendVoiceChat
    window.playVoice = playVoice
    window.playWelcomeVoice = playWelcomeVoice
    
    // ========== Character Chat Functions ==========
    
    // Start character voice input
    function startCharacterChat(novelId, novelTitle, genre) {
      const btn = document.getElementById(`char-voice-btn-${novelId}`)
      const status = document.getElementById(`char-status-${novelId}`)
      
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition
      if (!SpeechRecognition) {
        status.textContent = 'âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ï¼Œè¯·ä½¿ç”¨ Chrome'
        return
      }
      
      if (currentRecognition) {
        currentRecognition.stop()
        return
      }
      
      const recognition = new SpeechRecognition()
      recognition.lang = 'zh-CN'
      recognition.continuous = false
      recognition.interimResults = true
      
      recognition.onstart = () => {
        btn.classList.add('recording')
        btn.textContent = 'â¹ï¸'
        status.textContent = 'ğŸ¤ æˆ‘åœ¨å¬...'
      }
      
      recognition.onresult = (event) => {
        const transcript = Array.from(event.results)
          .map(result => result[0].transcript)
          .join('')
        document.getElementById(`char-input-${novelId}`).value = transcript
        status.textContent = `ğŸ“ ${transcript}`
      }
      
      recognition.onend = () => {
        btn.classList.remove('recording')
        btn.textContent = 'ğŸ¤'
        currentRecognition = null
        
        const input = document.getElementById(`char-input-${novelId}`)
        if (input.value.trim()) {
          sendCharacterChat(novelId, novelTitle, genre)
        } else {
          status.textContent = ''
        }
      }
      
      recognition.onerror = (event) => {
        btn.classList.remove('recording')
        btn.textContent = 'ğŸ¤'
        status.textContent = `âŒ ${event.error}`
        currentRecognition = null
      }
      
      currentRecognition = recognition
      recognition.start()
    }
    
    // Send character chat message
    async function sendCharacterChat(novelId, novelTitle, genre) {
      const input = document.getElementById(`char-input-${novelId}`)
      const sendBtn = document.getElementById(`char-send-${novelId}`)
      const voiceBtn = document.getElementById(`char-voice-btn-${novelId}`)
      const speechText = document.getElementById(`speech-text-${novelId}`)
      const speechPlay = document.getElementById(`speech-play-${novelId}`)
      const charWrapper = document.getElementById(`character-wrapper-${novelId}`)
      const speakingIndicator = document.getElementById(`speaking-indicator-${novelId}`)
      const status = document.getElementById(`char-status-${novelId}`)
      
      const message = input.value.trim()
      if (!message) return
      
      if (!chatHistories[novelId]) {
        chatHistories[novelId] = []
      }
      
      chatHistories[novelId].push({ role: 'user', content: message })
      input.value = ''
      sendBtn.disabled = true
      voiceBtn.disabled = true
      
      // Show thinking state
      speechText.textContent = 'è®©æˆ‘æƒ³æƒ³...'
      charWrapper.classList.remove('speaking')
      charWrapper.classList.add('thinking')
      speakingIndicator.classList.add('active')
      status.textContent = 'ğŸ¤” æ€è€ƒä¸­...'
      
      try {
        const chatResponse = await fetch(`${API_BASE_URL}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            message,
            novelTitle,
            genre,
            novelContent: novelContents[novelId] || '',
            chatHistory: chatHistories[novelId]
          }),
        })
        
        if (!chatResponse.ok) throw new Error('Chat failed')
        
        const chatData = await chatResponse.json()
        const reply = chatData.reply
        
        // Update speech bubble
        speechText.textContent = reply
        currentSpeechTexts[novelId] = reply
        chatHistories[novelId].push({ role: 'assistant', content: reply })
        
        // Switch to speaking animation
        charWrapper.classList.remove('thinking')
        charWrapper.classList.add('speaking')
        status.textContent = 'ğŸ”Š ç”Ÿæˆè¯­éŸ³ä¸­...'
        
        try {
          const ttsResponse = await fetch(`${API_BASE_URL}/api/tts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: reply, voice: 'nova' }),
          })
          
          if (ttsResponse.ok) {
            const ttsData = await ttsResponse.json()
            if (ttsData.audio) {
              const audio = new Audio(`data:${ttsData.mimeType};base64,${ttsData.audio}`)
              currentAudio = audio
              
              speechPlay.classList.add('playing')
              speechPlay.textContent = 'â¸ï¸'
              status.textContent = ''
              
              audio.onended = () => {
                speechPlay.classList.remove('playing')
                speechPlay.textContent = 'ğŸ”Š'
                charWrapper.classList.remove('speaking')
                speakingIndicator.classList.remove('active')
                currentAudio = null
              }
              
              await audio.play()
            }
          }
        } catch (ttsError) {
          console.error('TTS error:', ttsError)
          charWrapper.classList.remove('speaking')
          speakingIndicator.classList.remove('active')
        }
        
        status.textContent = ''
        
      } catch (error) {
        console.error('Character chat error:', error)
        speechText.textContent = 'æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æœ‰ç‚¹é—®é¢˜... ğŸ’”'
        charWrapper.classList.remove('thinking', 'speaking')
        speakingIndicator.classList.remove('active')
        status.textContent = ''
      } finally {
        sendBtn.disabled = false
        voiceBtn.disabled = false
      }
    }
    
    // Play current speech
    async function playCurrentSpeech(novelId) {
      const text = currentSpeechTexts[novelId] || 'å—¨ï½ç‚¹å‡»ä¸‹é¢çš„éº¦å…‹é£å’Œæˆ‘èŠå¤©å§ï½'
      const speechPlay = document.getElementById(`speech-play-${novelId}`)
      const charWrapper = document.getElementById(`character-wrapper-${novelId}`)
      const speakingIndicator = document.getElementById(`speaking-indicator-${novelId}`)
      
      if (currentAudio) {
        currentAudio.pause()
        currentAudio = null
        speechPlay.classList.remove('playing')
        speechPlay.textContent = 'ğŸ”Š'
        charWrapper.classList.remove('speaking')
        speakingIndicator.classList.remove('active')
        return
      }
      
      speechPlay.textContent = 'â³'
      charWrapper.classList.add('speaking')
      speakingIndicator.classList.add('active')
      
      try {
        const response = await fetch(`${API_BASE_URL}/api/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, voice: 'nova' }),
        })
        
        if (response.ok) {
          const data = await response.json()
          if (data.audio) {
            const audio = new Audio(`data:${data.mimeType};base64,${data.audio}`)
            currentAudio = audio
            
            speechPlay.classList.add('playing')
            speechPlay.textContent = 'â¸ï¸'
            
            audio.onended = () => {
              speechPlay.classList.remove('playing')
              speechPlay.textContent = 'ğŸ”Š'
              charWrapper.classList.remove('speaking')
              speakingIndicator.classList.remove('active')
              currentAudio = null
            }
            
            await audio.play()
          }
        }
      } catch (error) {
        console.error('Play speech error:', error)
        speechPlay.textContent = 'ğŸ”Š'
        charWrapper.classList.remove('speaking')
        speakingIndicator.classList.remove('active')
      }
    }
    
    // Make character chat functions globally available
    window.startCharacterChat = startCharacterChat
    window.sendCharacterChat = sendCharacterChat
    window.playCurrentSpeech = playCurrentSpeech
    
    // Continue Novel
    async function continueNovel(novelId, novelTitle, genre) {
      const promptInput = document.getElementById(`continue-prompt-${novelId}`)
      const btn = document.getElementById(`continue-btn-${novelId}`)
      const resultContainer = document.getElementById(`continuation-result-${novelId}`)
      const textContainer = document.getElementById(`continuation-text-${novelId}`)
      
      const direction = promptInput.value.trim()
      const novelContent = novelContents[novelId] || ''
      
      if (!direction) {
        alert('è¯·è¾“å…¥ä½ æƒ³çœ‹çš„å‰§æƒ…å‘å±•ï¼')
        promptInput.focus()
        return
      }
      
      if (!novelContent) {
        alert('å°è¯´å†…å®¹ä¸ºç©ºï¼Œæ— æ³•ç»­å†™')
        return
      }
      
      btn.disabled = true
      btn.textContent = 'â³ ç»­å†™ä¸­...'
      resultContainer.style.display = 'block'
      textContainer.innerHTML = '<p style="color: #666;">AI æ­£åœ¨åˆ›ä½œä¸­ï¼Œè¯·ç¨å€™...</p>'
      
      try {
        const response = await fetch(`${API_BASE_URL}/api/continue-novel`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            novelTitle,
            genre,
            novelContent,
            direction
          }),
        })
        
        if (!response.ok) {
          const error = await response.json()
          throw new Error(error.error || 'Failed to continue novel')
        }
        
        const data = await response.json()
        
        if (data.continuation) {
          // Format the continuation with proper line breaks
          const formatted = data.continuation
            .split('\n')
            .map(line => line.trim() ? `<p>${line}</p>` : '')
            .join('')
          
          textContainer.innerHTML = formatted || '<p>ç”Ÿæˆå®Œæˆ</p>'
        } else {
          throw new Error('No continuation generated')
        }
        
        promptInput.value = ''
      } catch (error) {
        console.error('Continuation error:', error)
        textContainer.innerHTML = `<p style="color: #c00;">âŒ ç»­å†™å¤±è´¥: ${error.message}</p>`
      } finally {
        btn.disabled = false
        btn.textContent = 'ğŸ“ ç»­å†™æ•…äº‹'
      }
    }
    
    // Make functions globally available
    window.generateSceneImage = generateSceneImage
    window.sendChat = sendChat
    window.continueNovel = continueNovel

    // Close modal
    function closeModal() {
      document.getElementById('novel-modal').classList.remove('active')
    }

    // Get currency symbol
    function getCurrencySymbol(currency) {
      const symbols = {
        'USD': '$',
        'CNY': 'Â¥',
        'EUR': 'â‚¬'
      }
      return symbols[currency] || '$'
    }

    // Close modal on outside click
    document.getElementById('novel-modal').addEventListener('click', (e) => {
      if (e.target.id === 'novel-modal') {
        closeModal()
      }
    })

    // Make functions available globally for onclick handlers
    window.showNovelDetail = showNovelDetail
    window.closeModal = closeModal
    window.handlePurchase = handlePurchase

    // Load novels on page load
    loadNovels()
    
    // Add timeout to show error if loading takes too long
    setTimeout(() => {
      const container = document.getElementById('novels-container')
      if (container && container.classList.contains('loading')) {
        container.className = 'empty-state'
        container.innerHTML = `
          <div class="empty-state">
            <h2>Loading Timeout</h2>
            <p>The request is taking too long. This is usually a CORS configuration issue.</p>
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border: 1px solid #ffc107;">
              <h3 style="margin: 0 0 10px 0; color: #856404;">âš ï¸ CORS Configuration Required</h3>
              <p style="margin: 0; color: #856404;">
                <strong>Steps to fix:</strong><br>
                1. Go to <a href="https://www.sanity.io/manage" target="_blank" style="color: #856404; text-decoration: underline;">https://www.sanity.io/manage</a><br>
                2. Select project: <strong>9cp0f5xw</strong><br>
                3. Go to <strong>API</strong> > <strong>CORS origins</strong><br>
                4. Add: <strong>${window.location.origin}</strong><br>
                5. Check <strong>Allow credentials</strong><br>
                6. Click <strong>Save</strong><br>
                7. Wait 10 seconds, then refresh this page
              </p>
            </div>
            <p style="margin-top: 10px; font-size: 12px;">
              <strong>Current URL:</strong> ${window.location.href}<br>
              <strong>Origin:</strong> ${window.location.origin}
            </p>
            <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Retry
            </button>
          </div>
        `
      }
    }, 10000) // 10 second timeout
  </script>
</body>
</html>
<!-- deployed Fri Feb 20 22:31:36 PST 2026 -->
